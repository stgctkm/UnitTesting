## Ⅰ. 単体テストとは
単体テストの目的はプロジェクトの成長を持続可能にすることであり、  
そのためには良質なテストが必要である。

良質な単体テストは  
読みやすさ、保守しやすさ、リファクタリングのしやすさを備えている。



### 1. なぜ、単体テストを行うのか
単体テストの目的はプロジェクトの成長を持続可能にすることである。  
優れたテストは
- 開発サイクルの中に組み込まれ
- 重要な部分のみがテスト対象であり
- 最小限の保守コストで最大限の価値を生み出す

目的達成には、
- テストケースの善し悪しの区別
- リファクタリング

が必要である。


### 2. 単体テストとは何か
単体テストとは
- 1単位の振る舞い（a unit of behavior）を検証し
- 実行時間の短い
- 他のテストケースから隔離された状態で実行される

テストである。

統合テストは単体テストの3条件を満たさないテストである。

### 3. 単体テストの構造的解析
単体テストでは準備、実行、確認の3つのフェーズで記述し、1単位の振る舞いを検証する。  
1単位の振る舞いを1APIで実行するよう設計し、実行フェーズは1行にする。  
テストケース間の結合度を弱めるよう準備フェーズを記述する。  
読みやすさのために、各フェーズの区切り、メソッド名に留意する。


## Ⅱ. 単体テストとその価値
ドメインモデル/アルゴリズムの単体テストが最も価値が高い.  
プロダクションコードのリファクタリングへの耐性、
迅速なフィードバック、  
テストケースの保守のしやすさを備えるようにし、  
状態ベースより出力値ベースの単体テストを作成する。  
過度に複雑なコードはドメインモデル/アルゴリズムとそれ以外に分割し, テストの価値を高める.  


### 4. 良い単体テストを構成する4本の柱
良い単体テストを構成する柱は次の4性質である
- 退行に対する保護
- リファクタリングへの耐性
- 迅速なフィードバック
- 保守のしやすさ

リファクタリングへの耐性は必須で、  
全てを最大に備えることはできないので  
単体テストでは迅速なフィードバックを  
結合テストでは退行に対する保護を備える  

### 5. モックの利用とテストの壊れやすさ
モックは出力（コマンド）の模倣に使用し、入力（クエリー）の模倣には（テストを壊れやすくするので）使用しない。  
副作用が外部から観察できるシステム間のコミュニケーションにはモックを使用できるが、  
システム内のコミュニケーションのテストにモックを使用するとテストを壊れやすくする

### 6. 単体テストの3つの手法
単体テストには  
- 出力値ベーステスト(副作用のない関数のテストで、最も質が高い)、  
- 状態ベーステスト(テスト対象と、協力者の状態を検証)、  
- コミュニケーションベーステスト(テスト対象と協力者のコミュニケーションを検証するテストでモックを使用するため、保守が困難)  
の3種類がある。


### 7. 単体テストの価値を高めるリファクタリング
プロダクションコードは
協力者オブジェクトの数/コードの複雑さ、ドメインにおける重要性の観点から
- ドメインモデル/アルゴリズム
- 取るに足らないコード
- 過度に複雑なコード
- コントローラ
に分類される。 ドメインモデル/アルゴリズのテストが最も価値の高い


## Ⅲ. 統合テスト
外部システムと統合したときに想定通りに機能することを検証するために、統合テストを行う.  
統合テストではビジネスシナリオごとに1件のハッピーパスを検証することで,  
管理下にある依存とのコミュニケーション, コントーローラーのテストを行う.  
統合テストでデータベースを直接利用することで, 退行に対する保護を得られる.  

### 8. なぜ統合テストを行うのか
統合テストはドメインモデルとプロセス外依存とを結合するコードをテストし, 
システムが意図したように機能するかを検証する.  
ビジネスシナリオを正常に終わらせるケース（ハッピーパス）で全てのプロセス外依存とのコミュニケーションを検証し,  
単体テストで検証できない異常ケースを検証する.  


### 9. モックのベストプラクティス
管理下にある依存にモックを使用すると、テストケースはリファクタリングへの耐性を失うため、  
モックは管理下にない依存のみに適用する。  
単体テストでは管理下にない依存を扱わないので、  
モックは統合テストに限定して使用する。  
モックを使用する際は、モックの呼び出し回数を確認する.


### 10. データベースに対するテスト
データベースは管理下にある依存なので、統合テストでは実際の依存を使用することで退行に対する保護を得る.    
他のテストケースへの影響を避けるため, テストの準備で, スキーマ, 参照データを用意し, テスト完了後にはデータの後始末を行う.  
本番環境と同じ環境でテストするため, テストケースの異なるフェーズでは同じトランザクションや単位作業を使いまわさない.  


## Ⅳ. 単体テストのアンチパターン
良い単体テストを構成する柱は次の4性質である
- 退行に対する保護
- リファクタリングへの耐性
- 迅速なフィードバック
- 保守のしやすさ

この4つの性質を損なうようなテストはアンチパターンなので、避ける

### 11. 単体テストのアンチパターン

テストを実装の詳細と結びつけると退行に対する保護を失うので、プライベートメソッドのテストはしない  
テストでは本番環境と同じ方法でテスト対象のコードとやり取りしなくてはならないので、プライベートな状態は公開しない  
リファクタリングへの耐性を失うため, テストコードにドメイン知識を記載しない  
プロダクションコードの保守コストが増えるため, テストに関するコードをプロダクションコードに記載しない  
具象クラスにモックを使わなくても良いように、テスト対象コードは単一責任の原則を遵守する  
テストケースに偽陽性を持ち込まないために、現在日時は明示的に依存として注入する























